# 2章 論理設計と物理設計

## 2-1. 概念スキーマと論理設計

概念スキーマを定義する設計を<strong>論理設計</strong>と呼ぶ。論理設計が物理設計より前に位置しているのは、この設計が物理制約には、原則として依存しないことを示している。

## 論理設計のステップ
(1)エンティティの抽出、(2)エンティティの定義、(3)正規化、(4)ER図の作成、という4つのステップを踏んで設計を行う。

### エンティティの抽出
エンティティは、日本語で「実態」と訳す。現実世界に存在するデータの集合体を指す言葉で、具体的には「顧客」や「社員」「店舗」「車」といった物理的実体をともなったものもあれば、「税」や「会社」「注文履歴」のように物理的実体を伴わない、匂いもなければ触れもしない、単なる概念としてしか存在しないものも含まれる。
RDBではこうした現実世界のエンティティを、最終的いには「テーブル」という物理的単位で格納していくことになる。そのため、まずはシステムのためにどのようなエンティティ（データ）が必要になるかを抽出することが、論理設計の第１ステップになる。

### エンティティの定義
エンティティを抽出した後は、各エンティティがどのようなデータを保持するかを決める必要がある。エンティティは、データを「属性（attribute）」という形で保持する。これは二次元表における「列」と同義と考えても良い。
RDBではテーブルというフォーマットでエンティティを保持するが、各表がどのような「列」を持つか定義するのがこの作業。

ここで重要なのが「キー」という列を定義すること。キーとはある特定の列の値を決定するための列のこと。

### 正規化
正規化（normalization）は、エンティティ（テーブル）について、システムでの利用gあスムーズに行えるようにする作業のこと。

### ER図の作成
ER図は、Entity-Relationship Diagram の略。正規化を行うと、エンティティの数が増える。
正規化はエンティティを細かく分割していく作業であり、それを行う途中でエンティティ同士の関係がわからなくなってしまうことがある。その問題を解決するために考案されたのが、エンティティ同士の関係を表現する図を作成するという方法である。

## 2-2. 内部スキーマと物理設計
物理設計は、論理設計の結果を受けて、データを格納するための物理的な領域や格納方法を決める工程。

## 物理設計のステップ

### テーブル定義
論理設計で定義された概念スキーマをもとに、それをDBMS内部に格納するための「テーブル」の単位に変換していく作業。

### インデックス定義
インデックス（索引）は、RDBにおいてテーブルと並んで重要な概念である。インデックスが重要な役割を果たすのが、非機能の部分、つまりパフォーマンス。

### ハードウェアのサイジング
システムで利用するデータサイズを見積もり、それに十分な容量の記憶装置を選定すること。また、システムが十分な性能を発揮できるようなスペックのCPUやメモリを持ったサーバーを選定すること。
データベースにおいては、データの整合性とパフォーマンスの間に強いトレードオフが存在する。つまり、整合性を高くしようとするとパフォーマンスが犠牲になり、パフォーマンスを追求すると整合性を犠牲にする、という二律背反の原則がある。
DB設計は限られた予算制約の中で、両端の間の平衡点を見つけ出そうとする努力だといっても良い。

#### キャパシティのサイジング
- システムで利用するデータ寮
  データベース内に格納するデータ量は、物理的なテーブル定義およびインデックス定義が終わらないと算出できない。したがって、この作業を実施するには、論理設計の終了が前提条件になる。
  ここまでのデータ寮には、データベース内に格納するテーブル以外にも、テキストや画像などのさまざまな形式のファイルの分も加算する必要がある。


### ストレージの冗長構成

データを失わないためにもできるだけ高い障害耐性を持つようにシステムを構築する必要がある。RAIDはRedundant Array of Independent Disksの略で、日本語に訳すと「独立したディスクの冗長配列」になる。
RAIDは本来システムの信頼性を高めるための技術だが、性能向上という面もある。

- RAID0
  - 別名ストライピング。ただデータを分散して持つだけなので、冗長性は全くない。
- RAID1
  - 別名ミラーリング。2本のディスクに全く同じデータおw持つ。信頼性が上がるが、ディスクの使用効率は悪い。
- RAID5
  - パリティ分散と呼ばれる。データとともに「パリティ」と呼ばれる誤り符号訂正符号を分散して格納する。一本までならパリティから実データを復元させることができる。また、データを分散できるためIO性能の向上も期待できる。
- RAID10
  - 別名「RAID0+1」とも呼ばれる。RAID1とRAID0を組み合わせたもの。信頼性と高速性が期待できるがコストが高い。

実際にどのRAIDを選ぶとなると、できればRAID10がいいが、最低限RAID5はほしいらしい。

### ファイルの物理配置
データベースの冗長構成が決まったら、物理設計の最終ステップはデータベースのファイルをどのディスク（またはRAIDグループ）に配置するかを考える。
最近のDBMSでは自動化が進んでおり、意識しなくても勝手に配置してくれるものもある。
データベースに格納されるファイルは、用途別に以下の5種類に大別できる。

1. データファイル
2. インデックスファイル
3. システムファイル
4. 一時ファイル
5. ログファイル

このうち、開発者が存在を意識するのはデータファイルとインデックスファイルだけ。
2. DBMSではテーブルとインデックスは普通異なるファイルとして管理される。このファイルお開発者が意識することはない。

5種類のファイルの物理配置を考えるとき、最も重要なことはサイズと性能。最もI/O量が多いのは1.データファイル。したがって、基本的な考え方としては、1と残りのファイルを異なるディスクに配置するということになる。
1の次に多いのがI/O量が多いのは2.インデックスファイルおよび4.一時ファイル。この二つのファイルもできれば独立したディスクに配置することが望ましい。5.ログファイルは、データ更新が多いシステムではI/O量が大きくなるが、一般的には1.データファイルの読み込み量に比べればそれほどでもない。

## 2-3. バックアップ設計
データベースには極めて重要な情報が一元管理されており、それが消えてしまうようなことがあってはならない。
RAID構成によってデータを極力失わないようにすることと、復旧できるようにしておくことが重要。本章では復旧の方法について解説する。

### バックアップの基本分類
1. 完全バックアップ
ある時点でそのシステムで保持されている全てのデータをバックアップする方式。バックアップの時間が長い、ハードウェアリソースへの負荷が高い、サービス停止が必要という欠点がある。

2. 差分バックアップ
最初だけフルバックアップをとって、それ移行は変更の差分だけバックアップを取る方式。復旧に必要なのは最初のフルバックアップしたデータと、最新の差分。

4. 増分バックアップ
前日からの増分を取る方式。差分と比べ、同じデータをバックアップするようなことが起こらないので効率が良いが、リカバリ手順が複雑になり、時間がかかってしまうことや、復旧に全てのデータが必要なために完全復旧の可能性が低くなってしまうという欠点がある。

### どんなバックアップ方式を採用すべき？
1. いつの時点の状態に復旧させる必要があるか。そもそも復旧の必要があるか。
2. バックアップに使用できる時間（バックアップウィンドウ）
3. リカバリに使用できる時間（リカバリウィンドウ）
4. 何世代までのデータを残す必要があるか

選択肢を網羅すると、次の4パターンになる。
1. バックアップしない
2. フルバックアップのみ
3. フルバックアップ＋差分バックアップ
4. フルバックアップ＋増分バックアップ

現実的に採用されることが多いのは3と4

## リカバリ設計
バックアップ設計とリカバリ設計はセットで実施することが一般的。これはバックアップ方式によってリカバリ手順が左右されるため。
バックアップをとってから次のバックアップを取るまでの間のデータは、バックアップデータからは復旧できない。そこにユーザーの変更分を再反映させなければリカバリは完結しない。

ここで、障害復旧の手順を厳密に二つに分ける必要がある。「バックアップファイルを戻す」作業を<strong>「リストア」</strong>、そのファイルに対して、トランザクションログを適用して変更分を反映する作業を<strong>「リカバリ」</strong>と呼ぶ。

### リストアとロールフォワード
重要なのはこの意味でのリカバリ。バックアップしておいたトランザクションログを適用することもリカバリなのですが、実はトランザクションログは、DBMS内部にも残っている。
その中に何が含まれているのかというと、最後のバックアップ後に実施されたユーザーからの変更分である。まだバックアップしていないだけで、データベースサーバーにはファイルとして残っている。（もちろんトランザクションログが破損していた場合は復旧負荷）
それゆえ、この未バックアップ分のトランザクションログまで適用することではじめてデータは障害直前まで復旧する。

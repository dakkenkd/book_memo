# 5. 論理設計とパフォーマンス

正規化はDB設計における基本。しかし、正規化されたテーブルは、往々にして現場のDBエンジニアから評判が良くない。それは、正規化がパフォーマンス上の深刻な問題を引き起こしてしまうからである。

## 5-1. 正規化の功罪
正規化のメリットはデータの整合性を保持することである。しかし、正規化されたテーブル群を検索する際、結合という処理を行うことによって速度の低下を招いてしまう。

### 正規化と非正規化どちらが正解なのか?
正規化と検索SQLのパフォーマンスは強いトレードオフの関係がある。筆者の立場としては「原則として非正規化は許さない」というスタンスをとっている。

## 5-2. 非正規化とパフォーマンス

### サマリーデータの冗長性とパフォーマンス
正規化、すなわち冗長性排除によって引き起こされる性能問題には、SQLの構文という観点からみると大きく2種類のパターンに分けられる。
一つ目がサマリーデータの冗長性排除によるパターンと、二つ目が選択条件の冗長性排除によるパターン。

以下のようなテーブルがあるとする。

## 5-3. 
|<u>受注ID</u>|受注日|注文者名義|
|----|----|----|
|0001|2012-01-05|岡野　武|
|0002|2012-01-05|浜田　洋一|
|0003|2012-01-06|石井 好子|
|0004|2012-01-07|若山　明子|

|<u>受注ID<u>|<u>注文明細連番</u>|注文者名義|
|----|----|----|
|0001|1|せんべい|
|0001|2|緑茶|
|0001|3|ごま油|
|0002|1|チョコレート|
|0002|1|紅茶|
|0003|2|ビスケット|

これに対して<strong>「受注日ごとに何個の商品が注文されているか」</strong>を調べようとすると、必ずテーブルの結合をする必要がある。
データが大きくなるにつれてかなりの計算時間を要するようになるため、パフォーマンスの低下の原因となる。

この問題は、ひとつの受注に対して「商品数」という列を追加することによって結合をする必要がなくなる。
しかし、このままでは{受注日}→{商品数}という推移的関数従属性があるため、第3正規形ではなくなってしまう。
したがって更新時における問題が発生することにはなるが、そのトレードオフとして検索処理が非常に簡単でハイパフォーマンスなものにできる。

次に、「受注日が2012-01-06から2012-01-07の期間に注文された商品の一覧を出力せよ」という問題を考える。
これにもテーブルの結合を行う必要があり、パフォーマンスに影響が出てしまう。
これを解決するためには、受注明細に「受注日の列」を追加する必要がある。しかし、そうすると {受注ID} → {受注日} という主キーの一部である「受注ID」から非キー列である「受注日」への部分関数従属性が生まれてしまい、第２正規形ではなくなってしまう。
そのトレードオフとして、検索を高速化できる。


正規化は可能な限り高次にすることが大原則であり、非正規化のことまで考慮してDB設計を行うことはそれほど多くはない。
